<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: 99_index.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

# ProFeTorch

> FB Prophet + Fastai + pyTorch.


This is an alternative implementation of prophet which uses quantile regression instead of MCMC sampling. It provides the following benefits over prophet:
- GPU usage.
- Strict(er) upper and lower bounds.
- Can add any other set of features to the time series.

The time series is implemented as follows:
\begin{align}
y &= b(T(t) + S(t) + F(x)|l,u) \\
T(t) &= mt + a \\
S(t) &= \sum_{n=1}^N\left(a_n \cos\left(\frac{2\pi nt}{P}\right) + b_n \sin\left(\frac{2\pi nt}{P}\right)\right) \\
F(x) &= w^T x\\
b(y|l,u) &= \begin{cases}
l \quad \text{if } y < l \\
y \quad \text{if } l < y < u \\
u \quad \text{if } y > u
\end{cases}
\end{align}
where $T(t)$ is the trend line, $S(t)$ are the seasonal components composed of a fourier sum, $F(x)$ is a linear function which weights features that is not related to time.

The task is therefore to find the parameters $a, m, \cup_n a_n, \cup_n b_n, w$ that minimises a loss function $l(\hat{y}, y)$. The default is set to minimise $l1$ loss $\frac{1}{N}\sum_{i=1}^N |y_i - \hat{y_i}|$ so that the reliance on outliers is minimised. By default we also calculate the 5th and 95th quantile by minimising the tilted loss function. The quantile functions are calculated as:
\begin{align}
y_5 &= b(\hat{y} - (m_5 t + a_5)|l,u) \\
y_{95} &= b(\hat{y} + (m_{95} t + a_{95})|l,u)
\end{align}

## Install

`pip install profetorch`

## How to use

Fill me in please! Don't forget code examples:
<div class="codecell" markdown="1">
<div class="input_area" markdown="1">

```python
import pandas as pd
import matplotlib.pyplot as plt

%load_ext autoreload
%autoreload 2
%matplotlib inline
```

</div>

</div>
<div class="codecell" markdown="1">
<div class="input_area" markdown="1">

```python
url = "https://raw.githubusercontent.com/facebook/prophet/master/examples/example_wp_log_peyton_manning.csv"
df = pd.read_csv(url)
df['ds'] = pd.to_datetime(df['ds'])
print(df.shape)
df.head()
```

</div>
<div class="output_area" markdown="1">

    (2905, 2)





<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>ds</th>
      <th>y</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>2007-12-10</td>
      <td>9.590761</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2007-12-11</td>
      <td>8.519590</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2007-12-12</td>
      <td>8.183677</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2007-12-13</td>
      <td>8.072467</td>
    </tr>
    <tr>
      <th>4</th>
      <td>2007-12-14</td>
      <td>7.893572</td>
    </tr>
  </tbody>
</table>
</div>



</div>

</div>
<div class="codecell" markdown="1">
<div class="input_area" markdown="1">

```python
plt.plot(df['ds'], df['y'])
plt.show()
```

</div>
<div class="output_area" markdown="1">

    /opt/miniconda3/lib/python3.7/site-packages/pandas/plotting/_matplotlib/converter.py:103: FutureWarning: Using an implicitly registered datetime converter for a matplotlib plotting method. The converter was registered by pandas on import. Future versions of pandas will require you to explicitly register matplotlib converters.
    
    To register the converters:
    	>>> from pandas.plotting import register_matplotlib_converters
    	>>> register_matplotlib_converters()
      warnings.warn(msg, FutureWarning)



![png](output_7_1.png)


</div>

</div>
<div class="codecell" markdown="1">
<div class="input_area" markdown="1">

```python
train_len = int(0.8*len(df))
train_df = df[:train_len]
test_df = df[train_len:]
```

</div>

</div>

## ProFeTorch Training
<div class="codecell" markdown="1">
<div class="input_area" markdown="1">

```python
model_params = {'y_n':10, 'm_n':7, 'l':0, 'h': train_df['y'].max() * 2}
model = Model(train_df, model_args=model_params, epochs=30, alpha=1e-2, beta=0)
model.fit(train_df)
```

</div>
<div class="output_area" markdown="1">

    /opt/miniconda3/lib/python3.7/site-packages/pandas/core/frame.py:4117: SettingWithCopyWarning: 
    A value is trying to be set on a copy of a slice from a DataFrame
    
    See the caveats in the documentation: http://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy
      errors=errors,




<div>
    <style>
        /* Turns off some styling */
        progress {
            /* gets rid of default border in Firefox and Opera. */
            border: none;
            /* Needs to be in here for Safari polyfill so background images work as expected. */
            background-size: auto;
        }
        .progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
            background: #F44336;
        }
    </style>
  <progress value='9' class='' max='30', style='width:300px; height:20px; vertical-align: middle;'></progress>
  30.00% [9/30 00:04<00:10]
</div>



<div>
    <style>
        /* Turns off some styling */
        progress {
            /* gets rid of default border in Firefox and Opera. */
            border: none;
            /* Needs to be in here for Safari polyfill so background images work as expected. */
            background-size: auto;
        }
        .progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
            background: #F44336;
        }
    </style>
  <progress value='0' class='' max='14', style='width:300px; height:20px; vertical-align: middle;'></progress>
  0.00% [0/14 00:00<00:00]
</div>



    Epoch 9/30 Training Loss: 0.4450, Validation Loss: 0.6734

</div>

</div>
<div class="codecell" markdown="1">
<div class="input_area" markdown="1">

```python
y_pred = model.predict(df)
plt.figure(figsize=(12,5))
plt.scatter(df['ds'], df['y'], label='Data')
plt.plot(train_df['ds'], y_pred[:train_len,1], c='r', label='Train Set')
plt.fill_between(train_df['ds'], y_pred[:train_len,0], y_pred[:train_len,2], alpha=0.5)
plt.plot(test_df['ds'], y_pred[train_len:,1], c='g', label='Test Set')
plt.fill_between(test_df['ds'], y_pred[train_len:,0], y_pred[train_len:,2], alpha=0.5)
plt.show()
```

</div>

</div>

Obviously more works needs to be done as seen in the graph above. However, note that:
1. The seasonal component is captured.
2. The quantiles are asymmetric, which cannot happen in the fb-prophet case.
